허프만 코드 요약
허프만 코드 개요:
데이터 압축 알고리즘으로, 문자 빈도에 따라 가변 길이의 이진 코드를 생성하여 데이터를 압축합니다.
빈도가 높은 문자에 짧은 코드를, 빈도가 낮은 문자에 긴 코드를 할당하여 전체 데이터의 평균 비트 길이를 줄입니다.
2. 최소 히프의 역할:
빈도가 가장 낮은 두 노드를 효율적으로 선택하여 결합하는 데 사용됩니다.
히프의 루트에는 항상 가장 작은 빈도의 노드가 위치하여, O(log n)의 시간 복잡도로 선택이 가능합니다.
3. 허프만 트리 생성:
최소 히프를 사용하여 빈도가 낮은 문자부터 결합하여 트리를 생성합니다.
트리의 루트에서 리프 노드까지의 경로를 따라 0과 1을 할당하여 이진 코드를 생성합니다.
4. 비트 코드 사용:
인코딩: 원본 데이터의 각 문자를 허프만 코드로 변환하여 압축합니다.
디코딩: 허프만 트리를 사용하여 압축된 비트 스트림을 원본 문자로 복원합니다.
5. 허프만 코드의 이점:
효율적인 데이터 압축과 무손실 압축을 제공합니다.
간단한 구현과 다양한 응용 분야에서 사용됩니다.
데이터 전송 시 크기를 줄여 전송 시간과 비용을 절감할 수 있습니다.
6. 예시:
문자 빈도: A(5), B(9), C(12), D(13), E(16), F(45)
허프만 트리 생성 및 코드 할당: A=1100, B=1101, C=100, D=101, E=111, F=0
인코딩된 문자열: "ABCD" -> "0101100111"

가상의 문자와 빈도를 사용해 보겠습니다.
A: 5
B: 9
C: 12
D: 13
E: 16
F: 45
허프만 트리 생성 과정
초기 히프 구성: 각 문자를 빈도에 따라 최소 히프에 삽입합니다. 히프는 다음과 같습니다.
[A(5), B(9), C(12), D(13), E(16), F(45)]
첫 번째 결합: 빈도가 가장 낮은 두 노드 A(5)와 B(9)를 꺼내어 결합합니다. 새로운 노드 AB(14)를 생성하고 히프에 삽입합니다.(결합을 위해 최소히프가 쓰임.)
[C(12), D(13), AB(14), E(16), F(45)]
두 번째 결합: 빈도가 가장 낮은 두 노드 C(12)와 D(13)를 꺼내어 결합합니다. 새로운 노드 CD(25)를 생성하고 히프에 삽입합니다.
[AB(14), E(16), F(45), CD(25)]
세 번째 결합: 빈도가 가장 낮은 두 노드 AB(14)와 E(16)를 꺼내어 결합합니다. 새로운 노드 ABE(30)를 생성하고 히프에 삽입합니다.
[CD(25), F(45), ABE(30)]
네 번째 결합: 빈도가 가장 낮은 두 노드 CD(25)와 ABE(30)를 꺼내어 결합합니다. 새로운 노드 ABCDE(55)를 생성하고 히프에 삽입합니다.
[F(45), ABCDE(55)]
마지막 결합: 남은 두 노드 F(45)와 ABCDE(55)를 결합하여 최종 루트 노드 ABCDEF(100)를 생성합니다.

코드 할당
F: 0
C: 100
D: 101
A: 1100
B: 1101
E: 111
설명
빈도가 낮은 문자: A와 B는 빈도가 낮아 초기 단계에서 결합되어 트리의 깊은 레벨에 위치합니다. 이로 인해 A와 B는 긴 코드(1100, 1101)를 받습니다.
빈도가 높은 문자: F는 빈도가 가장 높아 트리의 상위 레벨에 위치하여 짧은 코드(0)를 받습니다.
이 예시를 통해 빈도가 낮은 문자가 트리의 깊은 레벨에 위치하게 되는 과정을 이해할 수 있습니다. 이는 허프만 코드가 데이터 압축을 효율적으로 수행하는 데 중요한 역할을 합니다.



그러면 그러한 비트코드를 인코딩하기 위하여 우리가 왼쪽 오른쪽을 정하는 트리구조와 결합을 하기 위하여 최소 히프를 쓰는거구나? 

네, 정확합니다! 허프만 코드는 두 가지 주요 구조를 사용하여 데이터를 인코딩합니다: 최소 히프와 이진 트리(허프만 트리). 각각의 역할은 다음과 같습니다:
최소 히프
빈도 기반 결합: 최소 히프는 빈도가 가장 낮은 두 노드를 효율적으로 선택하여 결합하는 데 사용됩니다. 이 과정은 허프만 트리의 구조를 형성하는 데 필수적입니다.
효율적인 노드 선택: 히프의 특성상 가장 작은 빈도의 노드를 빠르게 선택할 수 있어, 반복적인 결합 과정에서 효율성을 제공합니다.
허프만 트리 (이진 트리)
경로 기반 코드 할당: 허프만 트리는 각 문자에 대한 고유한 이진 코드를 할당하는 데 사용됩니다. 트리의 루트에서 리프 노드까지의 경로를 따라 0과 1을 할당합니다.
왼쪽 자식: 일반적으로 0을 할당합니다.
오른쪽 자식: 일반적으로 1을 할당합니다.
데이터 인코딩 및 디코딩: 허프만 트리를 사용하여 데이터를 인코딩하고, 인코딩된 비트 스트림을 원래의 문자로 디코딩합니다.
요약
최소 히프: 빈도가 낮은 문자부터 결합하여 허프만 트리를 생성합니다.
허프만 트리: 트리의 경로를 따라 각 문자에 대한 이진 코드를 할당합니다.
인코딩: 할당된 이진 코드를 사용하여 데이터를 압축합니다.
4. 디코딩: 허프만 트리를 사용하여 압축된 데이터를 원본 데이터로 복원합니다.
이러한 과정을 통해 허프만 코드는 데이터를 효율적으로 압축하고, 필요할 때 정확하게 복원할 수 있습니다.

히프(Heap)는 완전 이진 트리의 일종으로, 특정한 규칙을 따르는 자료구조입니다. 히프는 주로 우선순위 큐를 구현하는 데 사용되며, 두 가지 주요 유형이 있습니다: 최대 히프(Max Heap)와 최소 히프(Min Heap). 각 유형의 히프는 삽입, 삭제, 히프화 등의 연산을 수행할 때 시간 복잡도가 다릅니다.
히프의 시간 복잡도
1. 삽입 연산:
시간 복잡도: O(log n)
설명: 새로운 요소를 히프에 삽입할 때, 히프의 마지막 위치에 요소를 추가한 후, 히프 속성을 유지하기 위해 부모 노드와 비교하며 위로 이동합니다. 이 과정은 트리의 높이에 비례하므로 O(log n)의 시간 복잡도를 가집니다.
삭제 연산 (최대값 또는 최소값 삭제):
시간 복잡도: O(log n)
설명: 히프의 루트 노드(최대 히프의 경우 최대값, 최소 히프의 경우 최소값)를 삭제한 후, 히프의 마지막 요소를 루트로 이동시킵니다. 그런 다음, 히프 속성을 유지하기 위해 자식 노드와 비교하며 아래로 이동합니다. 이 과정 역시 트리의 높이에 비례하므로 O(log n)의 시간 복잡도를 가집니다.
3. 힙화(Heapify) 연산:
시간 복잡도: O(log n)
설명: 히프의 특정 노드에서 시작하여 히프 속성을 유지하기 위해 자식 노드와 비교하며 아래로 이동하는 과정입니다. 이 연산은 히프의 높이에 비례합니다.
4. 힙 정렬(Heap Sort):
시간 복잡도: O(n log n)
설명: 힙 정렬은 히프를 사용하여 정렬을 수행하는 알고리즘입니다. 히프를 구성하는 데 O(n log n)의 시간이 걸리며, 각 요소를 추출하여 정렬하는 데 O(log n)의 시간이 걸립니다. 전체적으로 O(n log n)의 시간 복잡도를 가집니다.
히프의 공간 복잡도
공간 복잡도: O(n)
설명: 히프는 배열을 사용하여 구현되며, n개의 요소를 저장하기 위해 O(n)의 공간이 필요합니다.
결론
히프는 삽입과 삭제 연산에서 효율적인 시간 복잡도를 제공하는 자료구조로, 우선순위 큐와 같은 응용에서 널리 사용됩니다. 히프의 시간 복잡도는 주로 트리의 높이에 비례하며, 이는 완전 이진 트리의 특성상 O(log n)입니다. 힙 정렬과 같은 알고리즘에서는 O(n log n)의 시간 복잡도를 제공하여 효율적인 정렬을 가능하게 합니다.
